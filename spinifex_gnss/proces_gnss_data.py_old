"""
GNSS data processing and electron density calculation.

This module handles the core processing of GNSS observations to calculate
electron density at target ionospheric pierce points.

Refactored to:
- Remove DCB dependencies
- Pass IONEX data as parameter (downloaded in gnss_tec.py)
- Remove old density calculation method
"""

import numpy as np
from astropy.time import Time
import astropy.units as u
from astropy.coordinates import EarthLocation
from concurrent.futures import as_completed, ProcessPoolExecutor

from spinifex.geometry import IPP
from spinifex.ionospheric import tec_data
from spinifex.ionospheric.ionex_manipulation import (
    interpolate_ionex,
    IonexData,
)
from spinifex.ionospheric.iri_density import get_profile

from spinifex_gnss.parse_gnss import GNSSData
from spinifex_gnss.gnss_geometry import get_sat_pos, get_stat_sat_ipp
from spinifex_gnss.gnss_stations import gnss_pos_dict
from spinifex_gnss.tec_core import (
    getphase_tec,
    get_transmission_time,
    _get_cycle_slips,
)
from spinifex_gnss.config import (
    DISTANCE_KM_CUT,
    NDIST_POINTS,
    ELEVATION_CUT,
    INTERPOLATION_ORDER,
    GPS_TO_UTC_CORRECTION_DAYS,
    MAX_WORKERS_DENSITY,
)


def _get_distance_km(loc1: EarthLocation, loc2: EarthLocation) -> np.ndarray:
    """
    Calculate distance between two sets of locations.
    
    Parameters
    ----------
    loc1 : EarthLocation
        First location(s)
    loc2 : EarthLocation
        Second location(s)
        
    Returns
    -------
    np.ndarray
        Distance in kilometers
    """
    dx = loc1.x.value - loc2.x.value
    dy = loc1.y.value - loc2.y.value
    dz = loc1.z.value - loc2.z.value
    
    return np.sqrt(dx**2 + dy**2 + dz**2) / 1000.0  # Convert to km


def _get_gim_phase_corrected(
    phase_tec: np.ndarray,
    ipp_sat_stat: IPP,
    timeselect: np.ndarray,
    ionex: IonexData
) -> tuple[np.ndarray, np.ndarray]:
    """
    Correct carrier phase TEC using GIM (Global Ionospheric Map).
    
    Uses IONEX data to estimate and remove the carrier phase bias.
    
    Parameters
    ----------
    phase_tec : np.ndarray
        STEC from carrier phases (has unknown bias)
    ipp_sat_stat : IPP
        Ionospheric pierce points for satellite-station line of sight
    timeselect : np.ndarray
        Indices of times to correct
    ionex : IonexData
        Global ionospheric map data
        
    Returns
    -------
    tuple[np.ndarray, np.ndarray]
        - Bias-corrected STEC values
        - Standard deviation of correction per segment
    """
    cycle_slips = _get_cycle_slips(phase_tec=phase_tec)
    phase_bias = np.zeros_like(phase_tec)
    phase_std = np.zeros_like(phase_tec)
    
    default_options = tec_data.IonexOptions(remove_midnight_jumps=True)
    h_idx = np.argmin(
        np.abs(
            ipp_sat_stat.loc[0].height.to(u.km).value
            - default_options.height.to(u.km).value
        )
    )
    
    for seg in np.unique(cycle_slips):
        seg_idx = np.nonzero(cycle_slips == seg)[0]
        
        if seg_idx.shape[0] < 2:
            phase_bias[seg_idx] = np.nan
            continue
            
        if np.intersect1d(seg_idx, timeselect).size == 0:
            # Only correct times of interest
            continue
            
        ipp = ipp_sat_stat.loc[:, h_idx][seg_idx]
        elevation = ipp_sat_stat.altaz.alt.deg[seg_idx]
        
        gim_tec = interpolate_ionex(
            ionex,
            ipp.lon.deg,
            ipp.lat.deg,
            ipp_sat_stat.times[seg_idx],
            apply_earth_rotation=default_options.apply_earth_rotation,
        )
        
        high_el_mask = elevation > ELEVATION_CUT
        
        phase_bias[seg_idx] = np.nanmean(
            gim_tec[high_el_mask]
            * ipp_sat_stat.airmass[:, h_idx][seg_idx][high_el_mask]
            - phase_tec[seg_idx][high_el_mask],
        )
        
        data_count = np.sum(~np.isnan(phase_tec[seg_idx][high_el_mask]))
        if data_count > 1:
            phase_std[seg_idx] = np.nanstd(
                gim_tec[high_el_mask]
                * ipp_sat_stat.airmass[:, h_idx][seg_idx][high_el_mask]
                - phase_tec[seg_idx][high_el_mask]
            ) / np.sqrt(data_count)
        else:
            phase_std[seg_idx] = np.nan
    
    return phase_tec + phase_bias, phase_std


def _get_distance_ipp(
    stec_values: np.ndarray,
    stec_errors: np.ndarray,
    ipp_sat_stat: list[IPP],
    ipp_target: IPP,
    timeselect: np.ndarray,
    profiles: np.ndarray,
) -> list[list[np.ndarray]]:
    """
    Calculate VTEC and distance to target IPPs for interpolation.
    
    This function:
    1. Filters satellites by elevation and distance
    2. Converts STEC to VTEC using profiles
    3. Calculates lat/lon distances to target
    
    Parameters
    ----------
    stec_values : np.ndarray
        STEC values [satellites × times]
    stec_errors : np.ndarray
        STEC uncertainties [satellites × times]
    ipp_sat_stat : list[IPP]
        IPPs for each satellite
    ipp_target : IPP
        Target IPPs where density is needed
    timeselect : np.ndarray
        Time indices to process
    profiles : np.ndarray
        Normalized electron density profiles [times × heights]
        
    Returns
    -------
    list[list[np.ndarray]]
        Nested list [times][heights] of arrays with columns:
        [VTEC, VTEC_error, dlon, dlat]
    """
    Ntimes = ipp_target.times.shape[0]
    Nheights = ipp_target.loc[0].shape[0]
    Nprns = stec_values.shape[0]
    
    # Initialize arrays
    vtecs = np.full((Nprns, Ntimes, Nheights), np.nan, dtype=float)
    vtec_errors = np.full((Nprns, Ntimes, Nheights), np.nan, dtype=float)
    
    # Selection criteria
    el_select = np.array([
        ipp.altaz.alt.deg[timeselect] > ELEVATION_CUT
        for ipp in ipp_sat_stat
    ])  # prn × times
    
    el_select = np.logical_and(~np.isnan(stec_values[:, timeselect]), el_select)
    
    dist_select = np.array([
        _get_distance_km(ipp.loc[timeselect], ipp_target.loc) < DISTANCE_KM_CUT
        for ipp in ipp_sat_stat
    ])  # prn × times × heights
    
    prn_select = np.logical_and(el_select[:, :, np.newaxis], dist_select)
    
    # Calculate weighted airmass
    weighted_am = np.array([
        profiles * ipp.airmass[timeselect]
        for ipp in ipp_sat_stat
    ])  # prn × times × heights
    weighted_am = np.sum(weighted_am, axis=-1)
    
    # Convert STEC to VTEC
    vtec_values = profiles * (stec_values[:, timeselect] / weighted_am)[..., np.newaxis]
    vtec_error_values = profiles * stec_errors[:, timeselect][..., np.newaxis]
    
    # Calculate distances in degrees
    dlons = np.array([
        np.cos(ipp_target.loc.lat.rad) * (ipp.loc.lon.deg[timeselect] - ipp_target.loc.lon.deg)
        for ipp in ipp_sat_stat
    ])
    
    dlats = np.array([
        ipp.loc.lat.deg[timeselect] - ipp_target.loc.lat.deg
        for ipp in ipp_sat_stat
    ])
    
    # Apply selection
    vtecs[prn_select] = vtec_values[prn_select]
    vtec_errors[prn_select] = vtec_error_values[prn_select]
    
    # Package data for interpolation
    return [
        [
            np.concatenate((
                vtecs[:, timeidx, hidx][~np.isnan(vtecs[:, timeidx, hidx])][:, np.newaxis],
                vtec_errors[:, timeidx, hidx][~np.isnan(vtecs[:, timeidx, hidx])][:, np.newaxis],
                dlons[:, timeidx, hidx][~np.isnan(vtecs[:, timeidx, hidx])][:, np.newaxis],
                dlats[:, timeidx, hidx][~np.isnan(vtecs[:, timeidx, hidx])][:, np.newaxis],
            ), axis=-1)
            for hidx in range(Nheights)
        ]
        for timeidx in range(Ntimes)
    ]


def get_interpolated_tec(input_data: list[list[np.ndarray]]) -> np.ndarray:
    """
    Interpolate VTEC to target location using 2D polynomial fit.
    
    Fits a 2D polynomial to nearby measurements weighted by inverse variance,
    then evaluates at the target location (origin).
    
    Parameters
    ----------
    input_data : list[list[np.ndarray]]
        Nested list [times][heights] of arrays with columns:
        [VTEC, VTEC_error, dlon, dlat]
        
    Returns
    -------
    np.ndarray
        Electron density at target IPPs [times × heights]
        
    Notes
    -----
    Uses polynomial order from INTERPOLATION_ORDER config.
    Selects NDIST_POINTS nearest measurements for each interpolation.
    """
    fitted_density = np.zeros((len(input_data), len(input_data[0])))
    
    for timeidx, input_time in enumerate(input_data):
        for hidx, vtec_dlong_dlat in enumerate(input_time):
            if not vtec_dlong_dlat.shape or vtec_dlong_dlat.shape[0] < 2:
                # Not enough data for fitting
                continue
            
            # Select nearest NDIST_POINTS
            dist = np.linalg.norm(vtec_dlong_dlat[:, 2:], axis=1)
            dist_select = np.zeros(dist.shape, dtype=bool)
            nearest_indices = np.argpartition(
                dist, min(NDIST_POINTS, dist.shape[0] - 1), axis=0
            )[:NDIST_POINTS]
            dist_select[nearest_indices] = True
            
            # Build design matrix for polynomial fit
            A = np.ones(
                vtec_dlong_dlat[dist_select].shape[:1] +
                (((INTERPOLATION_ORDER) ** 2 + INTERPOLATION_ORDER) // 2,),
                dtype=float,
            )
            
            # Inverse variance weights
            weight = 1.0 / vtec_dlong_dlat[dist_select][:, 1]
            
            # Polynomial terms
            idx = 0
            for ilon in range(INTERPOLATION_ORDER):
                for ilat in range(INTERPOLATION_ORDER):
                    if ilon + ilat <= INTERPOLATION_ORDER - 1:
                        if idx > 0:
                            A[:, idx] = (
                                vtec_dlong_dlat[dist_select][:, 2] ** ilon *
                                vtec_dlong_dlat[dist_select][:, 3] ** ilat
                            )
                        idx += 1
            
            # Weighted least squares fit
            w = weight * np.eye(A.shape[0])
            AwT = A.T @ w
            
            try:
                par = (np.linalg.inv(AwT @ A) @ (AwT @ vtec_dlong_dlat[dist_select][:, :1])).squeeze()
                fitted_density[timeidx, hidx] = par[0]  # Constant term = value at origin
            except:
                # Singular matrix - not enough independent data
                continue
    
    return fitted_density


def get_gnss_station_density(
    gnss_data: GNSSData,
    ipp_target: IPP,
    profiles: np.ndarray,
    sp3_data,
    ionex: IonexData,
) -> list[list[np.ndarray]]:
    """
    Process one GNSS station to get VTEC and distances for interpolation.
    
    This is the main per-station processing function that:
    1. Calculates phase TEC for each satellite
    2. Corrects bias using GIM (passed as parameter)
    3. Calculates satellite positions and IPPs
    4. Returns data ready for spatial interpolation
    
    Parameters
    ----------
    gnss_data : GNSSData
        Observations from one station (single constellation)
    ipp_target : IPP
        Target IPPs where density is needed
    profiles : np.ndarray
        Normalized density profiles [times × heights]
    sp3_data : SP3Data
        Satellite orbit data
    ionex : IonexData
        Global ionospheric map for bias correction
        
    Returns
    -------
    list[list[np.ndarray]]
        Data structure for interpolation [times][heights]
        
    Notes
    -----
    No DCB corrections are applied.
    Uses GIM (IONEX) for carrier phase bias correction.
    IONEX data is passed as parameter (downloaded in gnss_tec.py).
    """
    prns = sorted(gnss_data.gnss.keys())
    stec_values = []
    stec_errors = []
    ipp_sat_stat = []
    
    # GPS to UTC time correction
    gpstime_correction = GPS_TO_UTC_CORRECTION_DAYS
    
    # Find nearest GNSS observation time for each target time
    timeselect = np.argmin(
        np.abs(
            ipp_target.times.mjd - gnss_data.times.mjd[:, np.newaxis] + gpstime_correction
        ),
        axis=0,
    )
    
    # Process each satellite
    for prn in prns:
        try:
            sat_data = gnss_data.gnss[prn]
            
            # Calculate transmission time (no DCB!)
            transmission_time = get_transmission_time(sat_data[:, 1], gnss_data.times)
            
            # Calculate phase TEC
            phase_stec = getphase_tec(
                sat_data[:, 2],
                sat_data[:, 3],
                constellation=gnss_data.constellation
            )
            
            # Get satellite positions
            sat_pos = get_sat_pos(sp3_data, transmission_time, prn)
            
            # Calculate IPPs
            ipp_sat_stat.append(
                get_stat_sat_ipp(
                    satpos=sat_pos,
                    gnsspos=gnss_pos_dict[gnss_data.station],
                    times=gnss_data.times,
                    height_array=ipp_target.loc[0].height,
                )
            )
            
            # Correct phase bias using GIM (passed as parameter!)
            stec_value, stec_error = _get_gim_phase_corrected(
                phase_stec, ipp_sat_stat[-1], timeselect, ionex
            )
            
            stec_values.append(stec_value)
            stec_errors.append(stec_error)
            
        except Exception as e:
            print(f"Failed for {gnss_data.station} {prn}: {e}")
    
    # Calculate distances and prepare for interpolation
    result = _get_distance_ipp(
        stec_values=np.array(stec_values),
        stec_errors=np.array(stec_errors),
        ipp_sat_stat=ipp_sat_stat,
        ipp_target=ipp_target,
        timeselect=timeselect,
        profiles=profiles,
    )
    
    # Free memory
    del gnss_data, stec_values, ipp_sat_stat
    
    return result


def get_ipp_density(
    ipp_target: IPP,
    gnss_data_list: list[GNSSData],
    sp3_data,
    ionex: IonexData,
) -> tec_data.ElectronDensity:
    """
    Calculate electron density at target IPPs from GNSS observations.
    
    This is the main processing function that:
    1. Gets density profiles from IRI model
    2. Processes each GNSS station in parallel
    3. Collects VTEC measurements from all stations
    4. Interpolates to target IPP locations
    
    Parameters
    ----------
    ipp_target : IPP
        Target ionospheric pierce points
    gnss_data_list : list[GNSSData]
        List of GNSS observations from all stations
    sp3_data : SP3Data
        Satellite orbit data
    ionex : IonexData
        Global ionospheric map for bias correction
        
    Returns
    -------
    tec_data.ElectronDensity
        Electron density and uncertainties at target IPPs
        
    Notes
    -----
    Uses parallel processing (ProcessPoolExecutor) for efficiency.
    No DCB corrections are applied.
    IONEX data is passed as parameter (downloaded in gnss_tec.py).
    """
    # Get density profiles from IRI model
    profiles = get_profile(ipp_target)
    
    Ntimes = ipp_target.times.shape[0]
    Nheights = ipp_target.loc.shape[1]
    
    # Initialize data collection structure
    all_data = [[[] for _ in range(Nheights)] for _ in range(Ntimes)]
    stec_gnss_data = {}
    
    # Process all stations in parallel
    with ProcessPoolExecutor(max_workers=MAX_WORKERS_DENSITY) as executor:
        # Submit all tasks
        future_to_station_constellation = {
            executor.submit(
                get_gnss_station_density,
                gnss_data,
                ipp_target,
                profiles,
                sp3_data,
                ionex,  # Pass IONEX data!
            ): gnss_data.station + gnss_data.constellation
            for gnss_data in gnss_data_list
        }
        
        # Collect results as they complete
        for future in as_completed(future_to_station_constellation):
            station = future_to_station_constellation[future]
            try:
                result = future.result()
                stec_gnss_data[station] = result
            except Exception as e:
                print(f"Error processing {station}: {e}")
                stec_gnss_data[station] = f"Error: {e}"
    
    # Combine data from all stations
    for station, station_data in stec_gnss_data.items():
        if isinstance(station_data, str):
            # Error occurred
            print(f"Skipping {station}: {station_data}")
            continue
            
        for itm in range(Ntimes):
            for hidx in range(Nheights):
                all_data[itm][hidx].append(station_data[itm][hidx])
    
    # Concatenate measurements from all stations
    for itm in range(Ntimes):
        for hidx in range(Nheights):
            if all_data[itm][hidx]:
                all_data[itm][hidx] = np.concatenate(all_data[itm][hidx], axis=0)
            else:
                all_data[itm][hidx] = np.array([])
    
    # Interpolate to target locations
    electron_density = get_interpolated_tec(all_data)
    
    # Clean up
    del stec_gnss_data, all_data
    
    return tec_data.ElectronDensity(
        electron_density=electron_density,
        electron_density_error=np.zeros_like(electron_density),  # TODO: propagate errors
    )
